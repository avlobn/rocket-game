<!DOCTYPE html>
<html lang="en" style="width: 100vw;max-width: 100vw;max-height: 100vw;">

<head>
    <meta charset="utf-8">
<script src="https://telegram.org/js/telegram-web-app.js?2"></script>
    <script>
        function setThemeClass() {
            document.documentElement.className = Telegram.WebApp.colorScheme;
        }

        Telegram.WebApp.onEvent('themeChanged', setThemeClass);
        setThemeClass();

    </script>  </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>RocketGame</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/css/Navbar-Centered-Brand-icons.css">
<style>
      canvas {
        background: #eee;
        display: block;
        margin: 0 auto;
      }
    </style>
<script type="application/javascript">

    /*
     * This is a demo code for Telegram WebApp for Bots
     * It contains basic examples of how to use the API
     * Note: all requests to backend are disabled in this demo, you should use your own backend
     */

    const DemoApp = {
        initData      : Telegram.WebApp.initData || '',
        initDataUnsafe: Telegram.WebApp.initDataUnsafe || {},
        MainButton: Telegram.WebApp.MainButton,
        BackButton: Telegram.WebApp.BackButton,
        SettingsButton: Telegram.WebApp.SettingsButton,

        init(options) {
            document.body.style.visibility = ''
            Telegram.WebApp.ready()
            Telegram.WebApp.MainButton.setParams({
                text      : 'CLOSE WEBVIEW',
                is_visible: true
            }).onClick(DemoApp.close)
            Telegram.WebApp.BackButton.onClick(function() {
                DemoApp.showAlert('Back button pressed')
            })
            Telegram.WebApp.SettingsButton.onClick(function() {
                DemoApp.showAlert('Settings opened!')
            })
        },
        expand() {
            Telegram.WebApp.expand();
        },
        close() {
            Telegram.WebApp.close();
        },
        toggleMainButton(el) {
            const mainButton = Telegram.WebApp.MainButton;
            if (mainButton.isVisible) {
                mainButton.hide();
                el.innerHTML = 'Show Main Button';
            } else {
                mainButton.show();
                el.innerHTML = 'Hide Main Button';
            }
        },
        toggleBackButton(el) {
            if (DemoApp.BackButton.isVisible) {
                DemoApp.BackButton.hide();
                el.innerHTML = 'Show Back Button';
            } else {
                DemoApp.BackButton.show();
                el.innerHTML = 'Hide Back Button';
            }
        },
        toggleSettingsButton(el) {
            if (DemoApp.SettingsButton.isVisible) {
                DemoApp.SettingsButton.hide();
                el.innerHTML = 'Show Settings Button';
            } else {
                DemoApp.SettingsButton.show();
                el.innerHTML = 'Hide Settings Button';
            }
        },
        toggleSwipeBehavior(el) {
            if (Telegram.WebApp.isVerticalSwipesEnabled) {
                Telegram.WebApp.disableVerticalSwipes();
                el.innerHTML = 'Enable Vertical Swypes';
            } else {
                Telegram.WebApp.enableVerticalSwipes();
                el.innerHTML = 'Disable Vertical Swypes';
            }
        },

        // version to string Example: '6.9'
        doesntSupport(version) {
            // console.log("version: " + version);
            // console.log("realVersion: " + this.version());
            // console.log("doesntSupport: " + this.isVersionAtLeast(version));
            if (!this.isVersionAtLeast(version)) {
                Telegram.WebApp.showAlert('This feature is not supported in this version of Telegram', function () {
                    Telegram.WebApp.close();
                });
                throw new Error('This feature is not supported in this version of Telegram');
            }
        },

        // actions
        sendMessage(msg_id, with_webview) {
            if (!DemoApp.initDataUnsafe.query_id) {
                alert('WebViewQueryId not defined');
                return;
            }

            document.querySelectorAll('button').forEach((btn) => btn.disabled = true);

            const btn       = document.querySelector('#btn_status');
            btn.textContent = 'Sending...';

            DemoApp.apiRequest('sendMessage', {
                msg_id      : msg_id || '',
                with_webview: !DemoApp.initDataUnsafe.receiver && with_webview ? 1 : 0
            }, function (result) {
                document.querySelectorAll('button').forEach((btn) => btn.disabled = false);

                if (result.response) {
                    if (result.response.ok) {
                        btn.textContent   = 'Message sent successfully!';
                        btn.className     = 'ok';
                        btn.style.display = 'block';
                    } else {
                        btn.textContent   = result.response.description;
                        btn.className     = 'err';
                        btn.style.display = 'block';
                        alert(result.response.description);
                    }
                } else if (result.error) {
                    btn.textContent   = result.error;
                    btn.className     = 'err';
                    btn.style.display = 'block';
                    alert(result.error);
                } else {
                    btn.textContent   = 'Unknown error';
                    btn.className     = 'err';
                    btn.style.display = 'block';
                    alert('Unknown error');
                }
            });
        },
        changeMenuButton(close) {
            document.querySelectorAll('button').forEach((btn) => btn.disabled = true);
            const btnStatus       = document.querySelector('#btn_status');
            btnStatus.textContent = 'Changing button...';

            DemoApp.apiRequest('changeMenuButton', {}, function (result) {
                document.querySelectorAll('button').forEach((btn) => btn.disabled = false);

                if (result.response) {
                    if (result.response.ok) {
                        btnStatus.textContent   = 'Button changed!';
                        btnStatus.className     = 'ok';
                        btnStatus.style.display = 'block';
                        Telegram.WebApp.close();
                    } else {
                        btnStatus.textContent   = result.response.description;
                        btnStatus.className     = 'err';
                        btnStatus.style.display = 'block';
                        alert(result.response.description);
                    }
                } else if (result.error) {
                    btnStatus.textContent   = result.error;
                    btnStatus.className     = 'err';
                    btnStatus.style.display = 'block';
                    alert(result.error);
                } else {
                    btnStatus.textContent   = 'Unknown error';
                    btnStatus.className     = 'err';
                    btnStatus.style.display = 'block';
                    alert('Unknown error');
                }
            });
            if (close) {
                setTimeout(function () {
                    Telegram.WebApp.close();
                }, 50);
            }
        },
        checkInitData() {
            const webViewStatus = document.querySelector('#webview_data_status');
            if (DemoApp.initDataUnsafe.query_id &&
                DemoApp.initData &&
                webViewStatus.classList.contains('status_need')
            ) {
                webViewStatus.classList.remove('status_need');
                DemoApp.apiRequest('checkInitData', {}, function (result) {
                    if (result.ok) {
                        webViewStatus.textContent = 'Hash is correct (async)';
                        webViewStatus.className   = 'ok';
                    } else {
                        webViewStatus.textContent = result.error + ' (async)';
                        webViewStatus.className   = 'err';
                    }
                });
            }
        },
        sendText(spam) {
            const textField = document.querySelector('#text_field');
            const text      = textField.value;
            if (!text.length) {
                return textField.focus();
            }
            if (byteLength(text) > 4096) {
                return alert('Text is too long');
            }

            const repeat = spam ? 10 : 1;
            for (let i = 0; i < repeat; i++) {
                Telegram.WebApp.sendData(text);
            }
        },
        sendTime(spam) {
            const repeat = spam ? 10 : 1;
            for (let i = 0; i < repeat; i++) {
                Telegram.WebApp.sendData(new Date().toString());
            }
        },
        switchInlineQuery(query, chooseChat) {
            if (chooseChat) {
                const chatTypes = []
                const types = ['users', 'bots', 'groups', 'channels'];
                for (let i = 0; i < types.length; i++) {
                    const el = document.getElementById('select-' + types[i]);
                    if (el.checked) {
                        chatTypes.push(types[i]);
                    }
                }

                if (!chooseChatTypes.length) {
                    return DemoApp.showAlert('Select chat types!');
                }

                Telegram.WebApp.switchInlineQuery(query, chatTypes)
            }

            Telegram.WebApp.switchInlineQuery(query, false)
        },

        // Alerts
        showAlert(message) {
            Telegram.WebApp.showAlert(message);
        },
        showConfirm(message) {
            Telegram.WebApp.showConfirm(message);
        },
        requestContact() {
            Telegram.WebApp.requestContact(function (result) {
                if (result) {
                    DemoApp.showAlert('Contact granted');
                } else {
                    DemoApp.showAlert('Contact denied');
                }
            });
        },
        isVersionAtLeast(version) {
            return Telegram.WebApp.isVersionAtLeast(version);
        },
        showPopup() {
            Telegram.WebApp.showPopup({
                title  : 'Popup title',
                message: 'Popup message',
                buttons: [
                    {id: 'delete', type: 'destructive', text: 'Delete all'},
                    {id: 'faq', type: 'default', text: 'Open FAQ'},
                    {type: 'cancel'},
                ]
            }, function (buttonId) {
                if (buttonId === 'delete') {
                    DemoApp.showAlert("'Delete all' selected");
                } else if (buttonId === 'faq') {
                    Telegram.WebApp.openLink('https://telegram.org/faq');
                }
            });
        },
        showScanQrPopup: function (linksOnly) {
            Telegram.WebApp.showScanQrPopup({
                text: linksOnly ? 'with any link' : 'for test purposes'
            }, function (text) {
                if (linksOnly) {
                    const lowerText = text.toString().toLowerCase();
                    if (lowerText.substring(0, 7) === 'http://' ||
                        lowerText.substring(0, 8) === 'https://'
                    ) {
                        setTimeout(function () {
                            Telegram.WebApp.openLink(text);
                        }, 50);

                        return true;
                    }
                } else {
                    DemoApp.showAlert(text);

                    return true;
                }
            });
        },

        // Permissions
        requestLocation(el) {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(function (position) {
                    el.nextElementSibling.innerHTML = '(' + position.coords.latitude + ', ' + position.coords.longitude + ')';
                    el.nextElementSibling.className = 'ok';
                });
            } else {
                el.nextElementSibling.innerHTML = 'Geolocation is not supported in this browser.';
                el.nextElementSibling.className = 'err';
            }
            return false;
        },
        requestVideo(el) {
            if (navigator.mediaDevices) {
                navigator.mediaDevices.getUserMedia({audio: false, video: true}).then(function (stream) {
                    el.nextElementSibling.innerHTML = '(Access granted)';
                });
            } else {
                el.nextElementSibling.innerHTML = 'Media devices is not supported in this browser.';
                el.nextElementSibling.className = 'err';
            }
            return false;
        },
        requestAudio(el) {
            if (navigator.mediaDevices) {
                navigator.mediaDevices.getUserMedia({audio: true, video: false}).then(function (stream) {
                    el.nextElementSibling.innerHTML = '(Access granted)';
                    el.nextElementSibling.className = 'ok';
                });
            } else {
                el.nextElementSibling.innerHTML = 'Media devices is not supported in this browser.';
                el.nextElementSibling.className = 'err';
            }
            return false;
        },
        requestAudioVideo(el) {
            if (navigator.mediaDevices) {
                navigator.mediaDevices.getUserMedia({audio: true, video: true}).then(function (stream) {
                    el.nextElementSibling.innerHTML = '(Access granted)';
                    el.nextElementSibling.className = 'ok';
                });
            } else {
                el.nextElementSibling.innerHTML = 'Media devices is not supported in this browser.';
                el.nextElementSibling.className = 'err';
            }
            return false;
        },
        testClipboard(el) {
            Telegram.WebApp.readTextFromClipboard(function (clipText) {
                if (clipText === null) {
                    el.nextElementSibling.innerHTML = 'Clipboard text unavailable.';
                    el.nextElementSibling.className = 'err';
                } else {
                    el.nextElementSibling.innerHTML = '(Read from clipboard: Â«' + clipText + 'Â»)';
                    el.nextElementSibling.className = 'ok';
                }
            });
            return false;
        },
        requestWriteAccess(el) {
            Telegram.WebApp.requestWriteAccess(function(allowed) {
                if (allowed) {
                    el.nextElementSibling.innerHTML = '(Access granted)'
                    el.nextElementSibling.className = 'ok'
                } else {
                    el.nextElementSibling.innerHTML = '(User declined this request)'
                    el.nextElementSibling.className = 'err'
                }
            })
        },
        requestPhoneNumber(el) {
            Telegram.WebApp.requestContact(function(sent, event) {
                if (sent) {
                    el.nextElementSibling.innerHTML = '(Phone number sent to the bot' + (event && event.responseUnsafe && event.responseUnsafe.contact && event.responseUnsafe.contact.phone_number ? ': +' + event.responseUnsafe.contact.phone_number : '') + ')'
                    el.nextElementSibling.className = 'ok'
                } else {
                    el.nextElementSibling.innerHTML = '(User declined this request)'
                    el.nextElementSibling.className = 'err'
                }
            })
        },
        requestServerTime(el) {
            Telegram.WebApp.invokeCustomMethod('getCurrentTime', {}, function(err, time) {
                if (err) {
                    el.nextElementSibling.innerHTML = '(' + err + ')'
                    el.nextElementSibling.className = 'err'
                } else {
                    el.nextElementSibling.innerHTML = '(' + (new Date(time * 1000)).toString() + ')'
                    el.nextElementSibling.className = 'ok'
                }
            });
        },

        // cloud storage
        cloudStorageKeys: {},
        cloudStorageItems: {},
        editCloudRow(el, event) {
            event.preventDefault();
            const values = DemoApp.cloudStorageItems
            const key = el.closest('tr').getAttribute('data-key')
            el.form.reset();
            el.form.key.value = key;
            el.form.value.value = values[key];
        },
        deleteCloudRow(el, event) {
            event.preventDefault();
            const key = el.closest('tr').getAttribute('data-key')
            Telegram.WebApp.CloudStorage.removeItem(key, function(err, deleted) {
                if (err) {
                    DemoApp.showAlert('Error: ' + err);
                } else {
                    if (deleted) {
                        const index = DemoApp.cloudStorageKeys.indexOf(key);
                        if (index >= 0) {
                            DemoApp.cloudStorageKeys.splice(index, 1);
                        }
                        delete DemoApp.cloudStorageItems[key];
                    }
                    el.form.reset();
                    DemoApp.updateCloudRows();
                }
            });
        },
        saveCloudForm(form, event) {
            event.preventDefault();
            const key = form.key.value
            const value = form.value.value
            Telegram.WebApp.CloudStorage.setItem(key, value, function(err, saved) {
                if (err) {
                    DemoApp.showAlert('Error: ' + err);
                } else {
                    if (saved) {
                        if (typeof DemoApp.cloudStorageItems[key] === 'undefined') {
                            DemoApp.cloudStorageKeys.push(key);
                        }
                        DemoApp.cloudStorageItems[key] = value;
                    }
                    form.reset();
                    DemoApp.updateCloudRows();
                }
            });
        },
        updateCloudRows() {
            let html = '';
            const keys = DemoApp.cloudStorageKeys;
            const values = DemoApp.cloudStorageItems;
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                html += '<tr data-key="'+cleanHTML(key)+'"><td>'+cleanHTML(key)+'</td><td>'+cleanHTML(values[key])+'</td><td><button onclick="DemoApp.editCloudRow(this, event);">Edit</button><button onclick="DemoApp.deleteCloudRow(this, event);">Delete</button></td></tr>';
            }

            document.getElementById('cloud_rows').innerHTML = html
        },
        loadCloudKeys(el) {
            Telegram.WebApp.CloudStorage.getKeys(function(err, keys) {
                if (err) {
                    DemoApp.showAlert('Error: ' + err);
                } else {
                    if (keys.length > 0) {
                        Telegram.WebApp.CloudStorage.getItems(keys, function(err, values) {
                            if (err) {
                                DemoApp.showAlert('Error: ' + err);
                            } else {
                                DemoApp.cloudStorageKeys = keys;
                                DemoApp.cloudStorageItems = {};
                                for (let i = 0; i < keys.length; i++) {
                                    const key = keys[i];
                                    DemoApp.cloudStorageItems[key] = values[key];
                                }
                                DemoApp.updateCloudRows();
                            }
                        });
                    }
                }
            });
        },

        // biometrics
        biometricInit(el) {
            const biometricManager = Telegram.WebApp.BiometricManager;
            if (!DemoApp.biometricInited) {
                DemoApp.biometricInited = true;
                Telegram.WebApp.onEvent('biometricManagerUpdated', function() {
                    document.getElementById('bm_inited').textContent = biometricManager.isInited ? 'true' : 'false'
                    document.getElementById('bm_available').textContent = biometricManager.isBiometricAvailable ? 'true' : 'false'
                    document.getElementById('bm_type').textContent = biometricManager.biometricType || ''
                    document.getElementById('bm_access_requested').textContent = biometricManager.isAccessRequested ? 'true' : 'false'
                    document.getElementById('bm_access_granted').textContent = biometricManager.isAccessGranted ? 'true' : 'false'
                    document.getElementById('bm_token_saved').textContent = biometricManager.isBiometricTokenSaved ? 'true' : 'false'
                    document.getElementById('bm_device_id').textContent = biometricManager.deviceId || ''
                    document.getElementById('bm_settings').style.display = biometricManager.isBiometricAvailable && biometricManager.isAccessRequested && !biometricManager.isAccessGranted ? 'block' : 'none'
                });
            }

            biometricManager.init();
        },
        biometricRequestAccess(el) {
            const biometricManager = Telegram.WebApp.BiometricManager;
            if (!biometricManager.isInited) {
                return DemoApp.showAlert('Biometric not inited yet!');
            }

            biometricManager.requestAccess({reason: 'The bot uses biometrics for testing purposes.'}, function(access_granted) {
                if (access_granted) {
                    el.nextElementSibling.innerHTML = '(Access granted)';
                    el.nextElementSibling.className = 'ok';
                } else {
                    el.nextElementSibling.innerHTML = '(Request declined)';
                    el.nextElementSibling.className = 'err';
                }
            });
        },
        biometricRequestAuth(el) {
            const biometricManager = Telegram.WebApp.BiometricManager;
            if (!biometricManager.isInited) {
                return DemoApp.showAlert('Biometric not inited yet!');
            }

            el.nextElementSibling.innerHTML = '';
            el.nextElementSibling.classList.remove('ok', 'err')

            biometricManager.authenticate({reason: 'The bot requests biometrics for testing purposes.'}, function(success, token) {
                if (success) {
                    el.nextElementSibling.innerHTML = '(Success, token: ' + token + ')';
                    el.nextElementSibling.className = 'ok';
                } else {
                    el.nextElementSibling.innerHTML = '(Failed)';
                    el.nextElementSibling.className = 'err';
                }
            });
        },
        biometricOpenSettings(el) {
            const biometricManager = Telegram.WebApp.BiometricManager;
            if (!biometricManager.isInited) {
                return DemoApp.showAlert('Biometric not inited yet!');
            }

            if (!biometricManager.isBiometricAvailable ||
                !biometricManager.isAccessRequested ||
                biometricManager.isAccessGranted) {
                return false;
            }

            biometricManager.openSettings();
        },
        biometricSetToken(el) {
            const biometricManager = Telegram.WebApp.BiometricManager;
            if (!biometricManager.isInited) {
                return DemoApp.showAlert('Biometric not inited yet!');
            }

            const token = parseInt(Math.random().toString().substring(2)).toString(16);
            biometricManager.updateBiometricToken(token, function(updated) {
                if (updated) {
                    document.getElementById('bm_token_saved').textContent = biometricManager.isBiometricTokenSaved ? 'true' : 'false'
                    el.nextElementSibling.innerHTML = '(Updated: ' + token + ')'
                    el.nextElementSibling.className = 'ok'
                } else {
                    el.nextElementSibling.innerHTML = '(Failed)'
                    el.nextElementSibling.className = 'err'
                }
            });
        },
        biometricRemoveToken(el) {
            const biometricManager = Telegram.WebApp.BiometricManager;
            if (!biometricManager.isInited) {
                return DemoApp.showAlert('Biometric not inited yet!');
            }

            biometricManager.updateBiometricToken('', function(updated) {
                if (updated) {
                    document.getElementById('bm_token_saved').textContent = biometricManager.isBiometricTokenSaved ? 'true' : 'false'
                    el.nextElementSibling.innerHTML = '(Removed)'
                    el.nextElementSibling.className = 'ok'
                } else {
                    el.nextElementSibling.innerHTML = '(Failed)'
                    el.nextElementSibling.className = 'err'
                }
            });
        },

        // Other
        apiRequest(method, data, onCallback) {
            // DISABLE BACKEND FOR FRONTEND DEMO
            // YOU CAN USE YOUR OWN REQUESTS TO YOUR OWN BACKEND
            // CHANGE THIS CODE TO YOUR OWN
            return onCallback && onCallback({error: 'This function (' + method + ') should send requests to your backend. Please, change this code to your own.'});

            const authData = DemoApp.initData || '';
            fetch('/demo/api', {
                method     : 'POST',
                body       : JSON.stringify(Object.assign(data, {
                    _auth : authData,
                    method: method,
                })),
                credentials: 'include',
                headers    : {
                    'Content-Type': 'application/json'
                }
            }).then(function (response) {
                return response.json();
            }).then(function (result) {
                onCallback && onCallback(result);
            }).catch(function (error) {
                onCallback && onCallback({error: 'Server error'});
            });
        }
    }

    const DemoAppMenu = {
        init() {
            DemoApp.init();
            document.body.classList.add('gray');
            Telegram.WebApp.setHeaderColor('secondary_bg_color');
        }
    };

    const DemoAppInitData = {
        init() {
            DemoApp.init();
            Telegram.WebApp.onEvent('themeChanged', function () {
                document.getElementById('theme_data').innerHTML = JSON.stringify(Telegram.WebApp.themeParams, null, 2);
            });
            document.getElementById('webview_data').innerHTML = JSON.stringify(DemoApp.initDataUnsafe, null, 2);
            document.getElementById('theme_data').innerHTML   = JSON.stringify(Telegram.WebApp.themeParams, null, 2);
            DemoApp.checkInitData();
        }
    };

    const DemoAppViewport = {
        init() {
            DemoApp.init();
            Telegram.WebApp.onEvent('viewportChanged', DemoAppViewport.setData);
            DemoAppViewport.setData();
        },
        setData() {
            document.querySelector('.viewport-border').setAttribute('text', window.innerWidth + ' x ' + round(Telegram.WebApp.viewportHeight, 2))
            document.querySelector('.viewport-stable_border').setAttribute('text', window.innerWidth + ' x ' + round(Telegram.WebApp.viewportStableHeight, 2) +
                ' | is_expanded: ' + (Telegram.WebApp.isExpanded ? 'true' : 'false'));
        }
    }

    function cleanHTML(value) {
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/\n/g, '<br/>')
    }

    function byteLength(str) {
        if (window.Blob) {
            try {
                return new Blob([str]).size;
            } catch (e) {
            }
        }

        let s = str.length;
        for (let i = str.length - 1; i >= 0; i--) {
            const code = str.charCodeAt(i);
            if (code > 0x7f && code <= 0x7ff) {
                s++;
            } else if (code > 0x7ff && code <= 0xffff) {
                s += 2;
            }

            if (code >= 0xDC00 && code <= 0xDFFF) {
                i--;
            }
        }
        return s;
    }

    function round(val, d) {
        const k = Math.pow(10, d || 0);
        return Math.round(val * k) / k;
    }
</script>

<script type="application/javascript">
    /*
     * This part of code is used to initialize the demo app and set up the event handlers we need.
     */

    Telegram.WebApp.onEvent('themeChanged', function () {
        document.getElementById('theme_data').innerHTML = JSON.stringify(Telegram.WebApp.themeParams, null, 2);
    });

    if (DemoApp.initDataUnsafe.query_id) {
        document.getElementById('main_btn').style.display = 'block';
    }
    document.getElementById('with_webview_btn').style.display = !!DemoApp.initDataUnsafe.query_id && !DemoApp.initDataUnsafe.receiver ? 'block' : 'none';
    document.getElementById('webview_data').innerHTML         = JSON.stringify(DemoApp.initDataUnsafe, null, 2);

    document.getElementById('theme_data').innerHTML = JSON.stringify(Telegram.WebApp.themeParams, null, 2);
    document.getElementById('regular_link').setAttribute('href', document.getElementById('regular_link').getAttribute('href') + location.hash);
    document.getElementById('text_field').focus();
    document.getElementById('regular_field').addEventListener('input', function (e) {
        const val = this.value.toLowerCase();
        if (val.indexOf('progress') >= 0) {
            Telegram.WebApp.MainButton.showProgress();
        } else {
            Telegram.WebApp.MainButton.hideProgress();
        }
    });

    document.getElementById('ver').innerHTML      = Telegram.WebApp.version;
    document.getElementById('platform').innerHTML = Telegram.WebApp.platform;

    if (DemoApp.initDataUnsafe.receiver) {
        document.getElementById('peer_wrap').style.display = 'block';
        document.getElementById('peer_name').innerHTML     = DemoApp.initDataUnsafe.receiver.first_name + ' ' + DemoApp.initDataUnsafe.receiver.last_name;
        if (DemoApp.initDataUnsafe.receiver.photo_url) {
            document.getElementById('peer_photo').setAttribute('src', DemoApp.initDataUnsafe.receiver.photo_url);
        } else {
            document.getElementById('peer_photo').style.display = 'none';
        }
    } else if (DemoApp.initDataUnsafe.chat) {
        document.getElementById('peer_wrap').style.display = 'block';
        document.getElementById('peer_name').innerHTML     = DemoApp.initDataUnsafe.chat.title;
        if (DemoApp.initDataUnsafe.chat.photo_url) {
            document.getElementById('peer_photo').setAttribute('src', DemoApp.initDataUnsafe.chat.photo_url);
        } else {
            document.getElementById('peer_photo').style.display = 'none';
        }
    }

    DemoApp.checkInitData();
    DemoApp.init();

    function setViewportData() {
        document.querySelector('.viewport-border').setAttribute('text', window.innerWidth + ' x ' + round(Telegram.WebApp.viewportHeight, 2))
        document.querySelector('.viewport-stable_border').setAttribute('text', window.innerWidth + ' x ' + round(Telegram.WebApp.viewportStableHeight, 2) +
            ' | is_expanded: ' + (Telegram.WebApp.isExpanded ? 'true' : 'false'));
    }

    Telegram.WebApp.setHeaderColor('secondary_bg_color');
    Telegram.WebApp.onEvent('viewportChanged', setViewportData);
    setViewportData();

    let prevBgColorVal   = document.getElementById('bg_color_sel').value;
    const bgColorInput   = document.getElementById('bg_color_input');
    const headerColorSel = document.getElementById('header_color_sel');

    bgColorInput.value = Telegram.WebApp.backgroundColor;
    document.body.setAttribute('style', '--bg-color:' + Telegram.WebApp.backgroundColor);
    headerColorSel.value = 'secondary_bg_color';
    headerColorSel.addEventListener('change', function (e) {
        const colorKey = e.target.value;
        document.getElementById('top_sect').classList.toggle('second', colorKey === 'secondary_bg_color');
        Telegram.WebApp.setHeaderColor(colorKey);
        document.body.setAttribute('style', '--bg-color:' + Telegram.WebApp.backgroundColor);
    });
    bgColorInput.addEventListener('change', function (e) {
        const color                                         = e.target.value;
        document.getElementById('bg_color_val').textContent = color;
        headerColorSel.value                                = 'custom';
        prevBgColorVal                                      = document.getElementById('bg_color_sel').value;
        Telegram.WebApp.setBackgroundColor(color);
        document.body.setAttribute('style', '--bg-color:' + Telegram.WebApp.backgroundColor);
    });
    headerColorSel.addEventListener('change', function (e) {
        const colorKey = e.target.value;
        if (colorKey === 'custom') {
            headerColorSel.value = prevBgColorVal;
            bgColorInput.focus();
        } else {
            document.getElementById('bg_color_val').textContent = 'custom...';
            Telegram.WebApp.setBackgroundColor(colorKey);
            document.body.setAttribute('style', '--bg-color:' + Telegram.WebApp.backgroundColor);
            bgColorInput.value = Telegram.WebApp.backgroundColor;
            prevBgColorVal     = headerColorSel.value;
        }
    });

    Telegram.WebApp.onEvent('themeChanged', function () {
        bgColorInput.value = Telegram.WebApp.backgroundColor;
        document.body.setAttribute('style', '--bg-color:' + Telegram.WebApp.backgroundColor);
    });

    try {
        DemoApp.testClipboard(document.getElementById('clipboard_test'));
    } catch(e) {}

    try {
        DemoApp.loadCloudKeys();
    } catch(e) {}

    try {
        DemoApp.biometricInit();
    } catch(e) {}
</script>
</head>

<body class="d-flex flex-column" style="width: 100%;height: 100%;display: flex;overflow: hidden;">
    <div class="container" style="max-height: 10vw;max-width: 100vw;min-width: 100vw;position: static;display: block;">
        <div class="row">
            <div class="col-md-3" style="max-height: 10vw;max-width: 15vw;min-height: 10vw;min-width: 15vw;"><img src="assets/img/696.jpg" style="max-height: 10vw;max-width: 10vw;min-height: 10vw;min-width: 10vw;"></div>
            <div class="col-md-3" style="display: block;max-width: 20vw;max-height: 10vw;min-width: 20vw;min-height: 10vw;">
                <div class="dropdown"><button class="btn btn-primary dropdown-toggle" aria-expanded="false" data-bs-toggle="dropdown" type="button" style="max-width: 20vw;min-width: 20vw;min-height: 10vw;max-height: 10vw;font-size: 2vw;padding: 0px;line-height: 10vw;">Login123456678</button>
                    <div class="dropdown-menu"><a class="dropdown-item" href="#">First Item</a><a class="dropdown-item" href="#">Second Item</a><a class="dropdown-item" href="#">Third Item</a></div>
                </div>
            </div>
            <div class="col-md-3 col-lg-3" style="display: block;max-width: 30vw;max-height: 10vw;min-height: 10vw;min-width: 30vw;"><strong style="max-width: 30vw;min-width: 30vw;min-height: 10vw;max-height: 10vw;font-size: 4.5vw;margin-left: 0px;padding-left: 1vw;letter-spacing: 0px;line-height: 9vw;text-align: left;">sefsffdf$</strong></div>
            <div class="col-md-3" style="max-width: 15vw;max-height: 10vw;min-width: 15vw;min-height: 10vw;margin-left: 17vw;"><img src="assets/img/fabulous-night-starry-sky-with-moon-in-a-gloomy-atmosphere-shrouded-in-mist-in-a-quiet-forest-epic-.png" style="min-width: 10vw;max-width: 10vw;min-height: 10vw;max-height: 10vw;"></div>
        </div>
    </div> <style>#loadingScreen {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.8); /* Полупрозрачный фон */
            font-size: 24px;
            font-family: Arial, sans-serif;
            z-index: 10; /* Поверх Canvas */
        }
        #actionMenu {
            position: absolute;
            display: none;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            z-index: 20;
            padding: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            min-width: 150px;
        }
        #actionMenu button {
            width: 100%;
            padding: 10px;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #f6d365 0%, #fda085 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #actionMenu button:hover {
            background: linear-gradient(135deg, #fda085 0%, #f6d365 100%);
        }
        #actionMenu button:active {
            transform: scale(0.98);
        }
        #generateMapButton {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 30;
            padding: 10px;
            background-color: #f0f0f0;
            border: 1px solid black;
            cursor: pointer;
        }
        canvas {
            border: 1px solid black;
            width: 80vw; /* 80% от ширины экрана */
            height: 80vh; /* 80% от высоты экрана */
            display: block; /* Убираем отступы */
            margin: auto; /* Центрируем Canvas */
            touch-action: none; /* Отключаем прокрутку и масштабирование по умолчанию */
        }
    </style>
    <div id="loadingScreen">Загрузка...</div>
    <div id="actionMenu">
        <button onclick="performAction('option1')">Действие 1</button>
        <button onclick="performAction('option2')">Действие 2</button>
    </div>
    <button id="generateMapButton" onclick="generateMap()">Сгенерировать карту</button>
<script src="mapGenerator.js"></script>
    <canvas id="gameCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loadingScreen');
        const actionMenu = document.getElementById('actionMenu');

        // Масштаб
     let scale = 1;
        let isDragging = false;
        
       let startX = 0, startY = 0;
let offsetX = 0, offsetY = 0;
        
        let startDistance = 0;
        let lastTap = 0; // Время последнего одиночного касания

        let cellSize;
let selectedRow;
        let selectedCol;
        // Карта, которая будет сгенерирована
        let map = [];

        // Загрузка изображений
        const images = {
            0: loadImage('imageGame/0.jpg'),
            1: loadImage('imageGame/1.png'),
            2: loadImage('imageGame/2.png'),
            3: loadImage('imageGame/3.png'),
            4: loadImage('imageGame/4.png'),
            5: loadImage('imageGame/5.png'),
            6: loadImage('imageGame/6.png'),
            7: loadImage('imageGame/7.png'),
            8: loadImage('imageGame/8.png'),
            9: loadImage('imageGame/9.png'),
            empty: loadImage('imageGame/empty.png'), // Изображение пустой ячейки
        };

        let imagesLoaded = 0;
        const totalImages = Object.keys(images).length;

        function loadImage(src) {
            const img = new Image();
            img.src = src;
            img.onload = () => {
                imagesLoaded++;
                console.log('Изображение загружено: ${src}'); // Лог загрузки
                if (imagesLoaded === totalImages) {
                    loadingScreen.style.display = 'none';
                    drawMap(); // Перерисовываем карту после загрузки изображений
                }
            };
            img.onerror = () => {
                console.error('Ошибка загрузки изображения: ${src}');
                img.src = 'imageGame/empty.png';
                img.onload = () => {
                imagesLoaded++;
if (imagesLoaded === totalImages) {
                    loadingScreen.style.display = 'none';
                    drawMap(); // Перерисовываем карту даже при ошибке загрузки
                }                
                
                }
                
            };
            return img;
        }

        // Обновляем размеры Canvas в зависимости от размеров окна
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            drawMap(); // Перерисовываем карту после изменения размеров
        }

        // Задаем начальный размер
        resizeCanvas();


        // Функция для отрисовки карты
        function drawMap() {
            cellSize = (canvas.width / map.length) * scale; // Обновляем размер ячеек

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Очищаем холст

            // Включаем сглаживание для улучшения качества изображения
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            for (let row = 0; row < map.length; row++) {
                for (let col = 0; col < map.length; col++) {
                    const value = map[row][col];
                    const image = images[value] || images['empty']; // Подставляем пустое изображение, если картинка не найдена

                    if (image) {
                        ctx.drawImage(image, col * cellSize, row * cellSize, cellSize, cellSize);
                    }

                    // Рисуем границу ячейки
                    ctx.strokeStyle = 'black';
                    ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
                }
           
            
            
            
            // Определяем массив цветов для рамок
    const borderColors = [
        'red', 'blue', 'green', 'orange', 'purple', 'cyan', 'magenta', 'yellow', 'gray', 'brown'
    ];
            // Рисуем цветные рамки для групп 10x10 ячеек
        const numRows = map.length;
        const numCols = map[0].length;

        for (let startRow = 0; startRow < numRows; startRow += 10) {
            for (let startCol = 0; startCol < numCols; startCol += 10) {
                const endRow = Math.min(startRow + 10, numRows);
                const endCol = Math.min(startCol + 10, numCols);

                // Определяем цвет рамки для текущего блока
                const colorIndex = Math.floor((startRow / 10) % borderColors.length);
                const borderColor = borderColors[colorIndex];

                // Рисуем рамку для блока 10x10
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 4; // Ширина рамки
                ctx.strokeRect(startCol * cellSize, startRow * cellSize, (endCol - startCol) * cellSize, (endRow - startRow) * cellSize);
            }
        } // Рисуем выделенную ячейку, если она есть
            if (selectedRow !== null && selectedCol !== null) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Полупрозрачный красный
                ctx.fillRect(selectedCol * cellSize + offsetX, selectedRow * cellSize + offsetY, cellSize, cellSize);
                
            }
        }}

      

        // Функция для отображения меню действий
        function showActionMenu(x, y, row, col) {
            actionMenu.style.display = 'block';
            actionMenu.style.left = '${x}px';
            actionMenu.style.top = '${y}px';

            // Сохраняем текущую позицию для использования в действиях
            actionMenu.dataset.row = row;
            actionMenu.dataset.col = col;
        }

        // Функция для выполнения действия
        function performAction(action) {
            const row = parseInt(actionMenu.dataset.row, 10);
            const col = parseInt(actionMenu.dataset.col, 10);
            console.log('Выполнение действия ${action} на ячейке (${row}, ${col})');
selectedRow=row;
            selectedCol=col;
            drawMap(); 
            // Пример действия - изменение изображения в ячейке
            if (action === 'option1') {
                map[row][col] = (map[row][col] + 1) % (Object.keys(images).length - 1);
                drawMap();
            }

            actionMenu.style.display = 'none'; // Скрыть меню после выбора действия
        }

        function handleTap(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.changedTouches[0].clientX - rect.left;
            const y = event.changedTouches[0].clientY - rect.top;

            const col = Math.floor((x - offsetX) / (50 * scale));
            const row = Math.floor((y - offsetY) / (50 * scale));
alert('Tapped on cell (${row}, ${col})');
            console.log('Tapped on cell (${row}, ${col})');
        showActionMenu(x, y, row, col)
        }
        
        resizeCanvas();
        
        window.addEventListener('resize', resizeCanvas);
         // Обработка событий касания
        canvas.addEventListener('touchstart', function(e) {
              e.preventDefault();
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const x = touch.clientX;
                const y = touch.clientY;
              isDragging = true;
                handleSingleTap(x, y);
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                startDistance = Math.sqrt(dx * dx + dy * dy);
                  isDragging = false;
            }
        });

        canvas.addEventListener('touchmove', function(e) {
            e.preventDefault();
           if (e.touches.length === 1 && isDragging) {
        // Обработка перетаскивания
        const touch = e.touches[0];
        const dx = touch.clientX - startX;
        const dy = touch.clientY - startY;
        offsetX = dx;
        offsetY = dy;
        drawMap();
    } else if (e.touches.length === 2) {
        // Обработка зума
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.sqrt(dx * dx + dy * dy);
        const delta = newDistance - startDistance;
        const zoomSpeed = 0.01;
        scale += delta * zoomSpeed;
        scale = Math.max(0.1, Math.min(scale, 5));
        startDistance = newDistance;
        
        isDragging = false;
        
        drawMap();
    }
        });

        // Обработка событий мыши
        canvas.addEventListener('mousedown', function(e) {
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
        });

        canvas.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                offsetX += dx;
                offsetY += dy;
                startX = e.clientX;
                startY = e.clientY;
                drawMap();
            }
        });

        canvas.addEventListener('mouseup', function() {
            isDragging = false;
        });

        canvas.addEventListener('wheel', function(e) {
            const zoomSpeed = 0.001;
            scale += e.deltaY * zoomSpeed;
            scale = Math.max(0.1, Math.min(scale, 5));
            drawMap();
        });

        // Обработка одиночных касаний
        function handleSingleTap(x, y) {
            const currentTime = new Date().getTime();
            const tapInterval = currentTime - lastTap;

            
                // Одиночное касание - добавьте здесь код для обработки одиночного касания
                console.log('Одиночное касание');
                 const col = Math.floor((x - offsetX) / cellSize);
                const row = Math.floor((y - offsetY) / cellSize);
                showActionMenu(x, y, row, col);
            

            lastTap = currentTime;
            
        }
    </script>
    <div class="container" style="max-height: 10vw;max-width: 100vw;min-width: 100vw;position: static;display: block;">
        <div class="row">
            <div class="col-md-3" style="max-height: 10vw;max-width: 15vw;min-height: 10vw;min-width: 15vw;"><img src="assets/img/696.jpg" style="max-height: 10vw;max-width: 10vw;min-height: 10vw;min-width: 10vw;"></div>
            <div class="col-md-3" style="display: block;max-width: 20vw;max-height: 10vw;min-width: 20vw;min-height: 10vw;">
                <div class="dropdown"><button class="btn btn-primary dropdown-toggle" aria-expanded="false" data-bs-toggle="dropdown" type="button" style="max-width: 20vw;min-width: 20vw;min-height: 10vw;max-height: 10vw;font-size: 2vw;padding: 0px;line-height: 10vw;">Login123456678</button>
                    <div class="dropdown-menu"><a class="dropdown-item" href="#">First Item</a><a class="dropdown-item" href="#">Second Item</a><a class="dropdown-item" href="#">Third Item</a></div>
                </div>
            </div>
            <div class="col-md-3 col-lg-3" style="display: block;max-width: 30vw;max-height: 10vw;min-height: 10vw;min-width: 30vw;"><strong style="max-width: 30vw;min-width: 30vw;min-height: 10vw;max-height: 10vw;font-size: 4.5vw;margin-left: 0px;padding-left: 1vw;letter-spacing: 0px;line-height: 9vw;text-align: left;">9999999 $</strong></div>
            <div class="col-md-3" style="max-width: 15vw;max-height: 10vw;min-width: 15vw;min-height: 10vw;margin-left: 17vw;"><img src="assets/img/fabulous-night-starry-sky-with-moon-in-a-gloomy-atmosphere-shrouded-in-mist-in-a-quiet-forest-epic-.png" style="min-width: 10vw;max-width: 10vw;min-height: 10vw;max-height: 10vw;"></div>
        </div>
    </div>
    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/bootstrap/js/bootstrap.min.js"></script>
</body>

</html>